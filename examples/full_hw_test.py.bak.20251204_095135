#!/usr/bin/env python3
"""
FULL HARDWARE AUTO-TEST FOR TOKYMON (with MIC + CAMERA)
------------------------------------------------------
Tests: LED Matrix → Audio (mic record+play) → Camera photo → IR → Ultrasonic → Motors → Final Display
Requires: TOKY_ENV=prod and sudo for full GPIO/PWM/camera access
"""

import time
import os
import sys
import subprocess
from pathlib import Path
from shutil import which

from display import max7219_driver as disp
from sensors.drivers.ir_sensor import read_left, read_right
from sensors.drivers.hcsr04 import read_distance_cm
from control import motors
from system.config import CONFIG


# ------------------------------------------------------------
# Helper: Get reliable temp directory
# ------------------------------------------------------------
def get_temp_dir():
    """Get a writable temp directory, creating if needed."""
    temp_dirs = [
        Path("/tmp"),
        Path.home() / "tmp",
        Path(CONFIG.get("runtime", {}).get("root_path", ".")) / "data" / "temp",
        Path(".") / "data" / "temp",
    ]
    
    for temp_dir in temp_dirs:
        try:
            temp_dir.mkdir(parents=True, exist_ok=True)
            # Test write
            test_file = temp_dir / ".write_test"
            test_file.write_text("test")
            test_file.unlink()
            return temp_dir
        except (PermissionError, OSError):
            continue
    
    # Last resort: current directory
    return Path(".")

TEMP_DIR = get_temp_dir()
print(f"[INFO] Using temp directory: {TEMP_DIR}")


# ------------------------------------------------------------
# Helper: safe print
# ------------------------------------------------------------
def header(title: str):
    print("\n" + "=" * 60)
    print(">>> " + title)
    print("=" * 60)


# ------------------------------------------------------------
# Test 1 — LED MATRIX
# ------------------------------------------------------------
def test_led():
    header("TEST 1 — LED MATRIX")
    try:
        disp.init_display()
        disp.show_text("TOKYMON")
        time.sleep(1)
        disp.show_expression("hello")
        time.sleep(1)
        disp.clear()
        print("[OK] LED Matrix test passed.")
    except Exception as e:
        print("[FAIL] LED test:", e)


# ------------------------------------------------------------
# Test 2 — AUDIO (MIC RECORD 5s + SPEAKER PLAY)
# ------------------------------------------------------------
def test_audio():
    header("TEST 2 — AUDIO (mic record 5s + playback)")
    
    # Use data/temp/Audio directory for audio files
    audio_dir = Path(CONFIG.get("runtime", {}).get("root_path", ".")) / "data" / "temp" / "Audio"
    audio_dir.mkdir(parents=True, exist_ok=True)
    outfile = str(audio_dir / "tokymon_test.wav")
    
    print(f"Recording 5 seconds to {outfile}")
    
    # Try recording with different devices
    record_devs = [None, "plughw:2,0", "plughw:1,0", "hw:2,0"]
    recorded = False
    
    for dev in record_devs:
        try:
            cmd = ["arecord", "-d", "5", "-f", "cd", outfile]  # 5 seconds
            if dev:
                cmd.insert(1, "-D")
                cmd.insert(2, dev)
            print(f"Trying recording device: {dev or 'default'}...")
            rc = subprocess.call(cmd, stderr=subprocess.DEVNULL, stdout=subprocess.DEVNULL)
            if rc == 0 and Path(outfile).exists() and Path(outfile).stat().st_size > 0:
                file_size = Path(outfile).stat().st_size
                print(f"Recording successful (device: {dev or 'default'}, size: {file_size} bytes)")
                print(f"Audio file saved to: {outfile}")
                recorded = True
                break
        except Exception as e:
            print(f"Recording attempt failed: {e}")
            continue
    
    if not recorded:
        print("[FAIL] Could not record audio from any device.")
        print("Try: arecord -l  # to list devices")
        return
    
    # Get available playback devices
    print("Checking available playback devices...")
    playback_devs = []
    try:
        result = subprocess.run(["aplay", "-l"], capture_output=True, text=True, timeout=2)
        if result.returncode == 0:
            # Parse output to find devices
            for line in result.stdout.split('\n'):
                if 'card' in line and 'device' in line:
                    # Extract card and device numbers
                    import re
                    match = re.search(r'card (\d+).*device (\d+)', line)
                    if match:
                        card, device = match.groups()
                        playback_devs.append(f"plughw:{card},{device}")
                        playback_devs.append(f"hw:{card},{device}")
    except:
        pass
    
    # Add fallback devices
    playback_devs.extend([None, "plughw:0,0", "plughw:1,0", "sysdefault", "default", "pulse"])
    
    # Try playback with different devices
    print("Playing recorded audio (5 seconds)...")
    played = False
    
    for dev in playback_devs:
        try:
            cmd = ["aplay", outfile]
            if dev:
                cmd.insert(1, "-D")
                cmd.insert(2, dev)
            print(f"Trying playback device: {dev or 'default'}...")
            rc = subprocess.call(cmd, stderr=subprocess.DEVNULL, stdout=subprocess.DEVNULL, timeout=10)
            if rc == 0:
                print(f"[OK] Playback successful (device: {dev or 'default'})")
                played = True
                break
        except subprocess.TimeoutExpired:
            print(f"Playback timeout on device: {dev or 'default'}")
            continue
        except Exception as e:
            continue
    
    if not played:
        print("[WARN] Playback failed on all devices.")
        print("Try: aplay -l  # to list available devices")
        print(f"Audio file saved at: {outfile}")
        print("You can manually play with: aplay -D <device> " + outfile)
    else:
        print("[OK] Audio test passed (5s record + playback).")


# ------------------------------------------------------------
# Test 3 — CAMERA PHOTO (CSI) - Capture and Show
# ------------------------------------------------------------
def test_camera():
    header("TEST 3 — CAMERA (capture and show)")
    
    # Use data/temp for camera photos
    camera_dir = Path(CONFIG.get("runtime", {}).get("root_path", ".")) / "data" / "temp"
    camera_dir.mkdir(parents=True, exist_ok=True)
    out_photo = str(camera_dir / "tokymon_photo.jpg")
    
    print(f"Capturing photo to: {out_photo}")
    
    # Check camera status first
    print("Checking camera status...")
    try:
        result = subprocess.run(["vcgencmd", "get_camera"], capture_output=True, text=True, timeout=2)
        if result.returncode == 0:
            print(f"Camera status: {result.stdout.strip()}")
    except:
        print("Could not check camera status (vcgencmd not available)")
    
    # Check for video devices
    try:
        video_devices = list(Path("/dev").glob("video*"))
        if video_devices:
            print(f"Found video devices: {[str(d) for d in video_devices]}")
        else:
            print("No /dev/video* devices found")
    except:
        pass
    
    # Try different camera binaries and paths with various options
    camera_commands = [
        # libcamera-still with different options
        (["libcamera-still", "-o", out_photo, "-t", "1000", "--timeout", "5000"], "libcamera-still"),
        (["libcamera-still", "-o", out_photo, "-t", "1000"], "libcamera-still (basic)"),
        (["/usr/bin/libcamera-still", "-o", out_photo, "-t", "1000", "--timeout", "5000"], "/usr/bin/libcamera-still"),
        # raspistill (legacy)
        (["raspistill", "-o", out_photo, "-t", "1000"], "raspistill"),
        (["/usr/bin/raspistill", "-o", out_photo, "-t", "1000"], "/usr/bin/raspistill"),
    ]
    
    captured = False
    last_error = None
    
    for cmd, name in camera_commands:
        binary_name = cmd[0].split('/')[-1]
        if not which(binary_name) and not Path(cmd[0]).exists():
            continue
        try:
            print(f"Trying {name}...")
            # Capture stderr to see actual errors
            result = subprocess.run(cmd, stderr=subprocess.PIPE, stdout=subprocess.PIPE, timeout=10)
            if result.returncode == 0 and Path(out_photo).exists() and Path(out_photo).stat().st_size > 0:
                file_size = Path(out_photo).stat().st_size
                print(f"[OK] Camera capture successful!")
                print(f"     File: {out_photo}")
                print(f"     Size: {file_size} bytes")
                print(f"     Using: {name}")
                
                # Show confirmation on LED display
                try:
                    disp.show_text("PHOTO")
                    time.sleep(1)
                    disp.show_expression("success")
                    time.sleep(1)
                    disp.clear()
                except Exception as e:
                    print(f"LED display warning: {e}")
                
                # Try to show image (if viewer available)
                try:
                    if which("feh"):
                        print(f"Opening image with feh...")
                        subprocess.Popen(["feh", out_photo], stderr=subprocess.DEVNULL, stdout=subprocess.DEVNULL)
                    elif which("xdg-open"):
                        print(f"Opening image with xdg-open...")
                        subprocess.Popen(["xdg-open", out_photo], stderr=subprocess.DEVNULL, stdout=subprocess.DEVNULL)
                    else:
                        print(f"Image saved. View with: feh {out_photo}  or  xdg-open {out_photo}")
                except:
                    print(f"Image saved. View with: feh {out_photo}  or  xdg-open {out_photo}")
                
                captured = True
                break
            else:
                # Capture error message
                if result.stderr:
                    error_msg = result.stderr.decode('utf-8', errors='ignore').strip()
                    if error_msg:
                        last_error = error_msg
                        print(f"  Error: {error_msg[:100]}")
        except subprocess.TimeoutExpired:
            print(f"  Timeout waiting for camera")
            continue
        except Exception as e:
            last_error = str(e)
            print(f"  Exception: {e}")
            continue
    
    if not captured:
        print("[FAIL] Camera capture failed.")
        if last_error:
            print(f"Last error: {last_error}")
        print("\nTroubleshooting steps:")
        print("1. Check camera status: vcgencmd get_camera")
        print("   Should show: supported=1 detected=1")
        print("\n2. For Raspberry Pi 5 / newer OS:")
        print("   Camera interface may need to be enabled in /boot/firmware/config.txt")
        print("   Add or uncomment: camera_auto_detect=1")
        print("   Or edit: sudo nano /boot/firmware/config.txt")
        print("   Then reboot: sudo reboot")
        print("\n3. For older Pi models:")
        print("   Enable via: sudo raspi-config -> Interface Options -> Camera -> Enable")
        print("   Or add to /boot/config.txt: start_x=1")
        print("\n4. Check camera connection:")
        print("   ls -la /dev/video*")
        print("   Should show /dev/video0 or /dev/video10+")
        print("\n5. Test manually:")
        print("   libcamera-still -o /tmp/test.jpg")
        print("   If that works, camera is OK but script needs different options")
        print("\n6. Install/update camera tools:")
        print("   sudo apt-get update")
        print("   sudo apt-get install -y libcamera-apps")
        print(f"\nFiles will be saved to: {camera_dir}")


# ------------------------------------------------------------
# Test 4 — IR SENSORS
# ------------------------------------------------------------
def test_ir():
    header("TEST 4 — IR SENSORS (Active-low: 0=Detect)")
    try:
        l = read_left()
        r = read_right()
        print(f"Left IR:  {l}")
        print(f"Right IR: {r}")
        print("[OK] IR test done.")
    except Exception as e:
        print("[FAIL] IR test:", e)


# ------------------------------------------------------------
# Test 5 — ULTRASONIC SENSOR
# ------------------------------------------------------------
def test_ultrasonic():
    header("TEST 5 — ULTRASONIC HC-SR04")
    try:
        d = read_distance_cm()
        print(f"Distance: {d} cm")
        print("[OK] Ultrasonic test done.")
    except Exception as e:
        print("[FAIL] Ultrasonic test:", e)


# ------------------------------------------------------------
# Test 6 — MOTORS (TB6612)
# ------------------------------------------------------------
def test_motors():
    header("TEST 6 — MOTORS (TB6612)")
    try:
        print("Forward 1s...")
        motors.forward()
        time.sleep(1)

        print("Backward 1s...")
        motors.backward()
        time.sleep(1)

        print("Turn Left 1s...")
        motors.turn_left()
        time.sleep(1)

        print("Turn Right 1s...")
        motors.turn_right()
        time.sleep(1)

        print("STOP")
        motors.stop()
        time.sleep(0.3)

        print("[OK] Motors test done.")
    except Exception as e:
        print("[FAIL] Motor test:", e)
        try:
            motors.stop()
        except:
            pass


# ------------------------------------------------------------
# Final
# ------------------------------------------------------------
def final_ok():
    header("ALL TESTS COMPLETED")
    try:
        disp.show_text("OK")
        time.sleep(1)
        disp.clear()
    except:
        pass


# ------------------------------------------------------------
# RUN ALL
# ------------------------------------------------------------
if __name__ == "__main__":
    print("\nTOKYMON — FULL HARDWARE AUTO-TEST (MIC + CAMERA INCLUDED)")
    print("Starting...\n")

    test_led()
    test_audio()
    test_camera()
    test_ir()
    test_ultrasonic()
    test_motors()
    final_ok()

    print("\nDONE.\n")
