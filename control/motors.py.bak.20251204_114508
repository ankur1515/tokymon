"""TB6612FNG motor driver (adapted from raw_scripts/tb6612_Fix.py)."""
from __future__ import annotations

import time
import os

from system.config import CONFIG
from system.logger import get_logger

LOGGER = get_logger("motors")

USE_SIM = CONFIG["services"]["runtime"].get("use_simulator", False)
TOKY_ENV = os.environ.get("TOKY_ENV", "dev").lower()

# Pin definitions - try CONFIG first, fallback to TB6612 defaults
try:
    PINS = CONFIG["pinmap"]["motors"]
    PWMA_PIN = PINS.get("motor_a", {}).get("pwm", PINS.get("motor_a", {}).get("in1", 12))
    AIN1_PIN = PINS.get("motor_a", {}).get("in1", 5)
    AIN2_PIN = PINS.get("motor_a", {}).get("in2", 6)
    PWMB_PIN = PINS.get("motor_b", {}).get("pwm", PINS.get("motor_b", {}).get("in3", 13))
    BIN1_PIN = PINS.get("motor_b", {}).get("in1", PINS.get("motor_b", {}).get("in3", 20))
    BIN2_PIN = PINS.get("motor_b", {}).get("in2", PINS.get("motor_b", {}).get("in4", 21))
    STBY_PIN = PINS.get("standby", 22)
    LOGGER.info("Using motor pins from CONFIG")
except (KeyError, TypeError):
    # Fallback to TB6612 defaults
    PWMA_PIN = 12
    AIN1_PIN = 5
    AIN2_PIN = 6
    PWMB_PIN = 13
    BIN1_PIN = 20
    BIN2_PIN = 21
    STBY_PIN = 22
    LOGGER.warning("Using fallback TB6612 pin defaults")

# Global GPIO offset for Pi5 sysfs
GLOBAL_OFFSET = 569
PWMA = PWMA_PIN + GLOBAL_OFFSET
AIN1 = AIN1_PIN + GLOBAL_OFFSET
AIN2 = AIN2_PIN + GLOBAL_OFFSET
PWMB = PWMB_PIN + GLOBAL_OFFSET
BIN1 = BIN1_PIN + GLOBAL_OFFSET
BIN2 = BIN2_PIN + GLOBAL_OFFSET
STBY = STBY_PIN + GLOBAL_OFFSET

# Motor driver state
_h = None
_pwm_frequency = 1000
_initialized = False


def _init_driver():
    """Initialize motor driver (TB6612)."""
    global _h, _initialized
    if _initialized:
        return

    if USE_SIM:
        LOGGER.info("Motor driver: simulator mode (no hardware init)")
        _initialized = True
        return

    # Try lgpio first (for PWM support on Pi5)
    try:
        import lgpio as GPIO
        _h = GPIO.gpiochip_open(0)
        LOGGER.info("TB6612 driver initialized: GPIO Chip 0 opened (lgpio)")

        # Claim all pins as OUTPUT
        output_pins = [PWMA_PIN, AIN1_PIN, AIN2_PIN, PWMB_PIN, BIN1_PIN, BIN2_PIN, STBY_PIN]
        for pin in output_pins:
            GPIO.gpio_claim_output(_h, pin)

        # Initialize STBY to HIGH to enable the motor driver
        GPIO.gpio_write(_h, STBY_PIN, GPIO.HIGH)
        LOGGER.info(f"Driver enabled: STBY (GPIO{STBY_PIN}) set HIGH")

        # Start PWM at 0% duty cycle (stopped)
        GPIO.tx_pwm(_h, PWMA_PIN, _pwm_frequency, 0)
        GPIO.tx_pwm(_h, PWMB_PIN, _pwm_frequency, 0)
        LOGGER.info(f"PWM ready on GPIO{PWMA_PIN} and GPIO{PWMB_PIN} at {_pwm_frequency}Hz")
        _initialized = True
        return
    except ImportError:
        LOGGER.warning("lgpio not available; using basic GPIO control")
    except Exception as e:
        LOGGER.warning("lgpio init failed: %s; using basic GPIO control", e)

    # Fallback to rpi_gpio (basic on/off, no PWM)
    from drivers import rpi_gpio
    for pin in [AIN1, AIN2, BIN1, BIN2, STBY]:
        rpi_gpio.setup(pin, "out")
    rpi_gpio.write(STBY, True)  # Enable driver
    LOGGER.info("TB6612 driver initialized: using basic GPIO (no PWM)")
    _initialized = True


def _set_motor_speed(speed_a: int, speed_b: int):
    """Set PWM duty cycle for both motors (0-100)."""
    if USE_SIM:
        LOGGER.debug("Motor speed (sim): A=%s%%, B=%s%%", speed_a, speed_b)
        return

    speed_a = max(0, min(100, speed_a))
    speed_b = max(0, min(100, speed_b))

    if _h is not None:
        try:
            import lgpio as GPIO
            GPIO.tx_pwm(_h, PWMA_PIN, _pwm_frequency, speed_a)
            GPIO.tx_pwm(_h, PWMB_PIN, _pwm_frequency, speed_b)
        except Exception as e:
            LOGGER.warning("PWM set failed: %s", e)
    else:
        # Basic GPIO mode: speed not supported, just on/off
        from drivers import rpi_gpio
        rpi_gpio.write(PWMA, speed_a > 0)
        rpi_gpio.write(PWMB, speed_b > 0)


def _set_direction(motor_side: str, direction: str):
    """Set motor direction (forward/backward/coast/brake)."""
    if USE_SIM:
        LOGGER.debug("Motor %s direction (sim): %s", motor_side, direction)
        return

    if _h is not None:
        try:
            import lgpio as GPIO
            if motor_side == 'A':
                pin1, pin2 = AIN1_PIN, AIN2_PIN
                if direction == 'forward':
                    GPIO.gpio_write(_h, pin1, GPIO.LOW)
                    GPIO.gpio_write(_h, pin2, GPIO.HIGH)
                elif direction == 'backward':
                    GPIO.gpio_write(_h, pin1, GPIO.HIGH)
                    GPIO.gpio_write(_h, pin2, GPIO.LOW)
                elif direction == 'coast':
                    GPIO.gpio_write(_h, pin1, GPIO.LOW)
                    GPIO.gpio_write(_h, pin2, GPIO.LOW)
                elif direction == 'brake':
                    GPIO.gpio_write(_h, pin1, GPIO.HIGH)
                    GPIO.gpio_write(_h, pin2, GPIO.HIGH)
            elif motor_side == 'B':
                pin1, pin2 = BIN1_PIN, BIN2_PIN
                if direction == 'forward':
                    GPIO.gpio_write(_h, pin1, GPIO.HIGH)
                    GPIO.gpio_write(_h, pin2, GPIO.LOW)
                elif direction == 'backward':
                    GPIO.gpio_write(_h, pin1, GPIO.LOW)
                    GPIO.gpio_write(_h, pin2, GPIO.HIGH)
                elif direction == 'coast':
                    GPIO.gpio_write(_h, pin1, GPIO.LOW)
                    GPIO.gpio_write(_h, pin2, GPIO.LOW)
                elif direction == 'brake':
                    GPIO.gpio_write(_h, pin1, GPIO.HIGH)
                    GPIO.gpio_write(_h, pin2, GPIO.HIGH)
        except Exception as e:
            LOGGER.warning("Direction set failed: %s", e)
    else:
        # Fallback to rpi_gpio
        from drivers import rpi_gpio
        if motor_side == 'A':
            if direction == 'forward':
                rpi_gpio.write(AIN1, False)
                rpi_gpio.write(AIN2, True)
            elif direction == 'backward':
                rpi_gpio.write(AIN1, True)
                rpi_gpio.write(AIN2, False)
            elif direction in ('coast', 'brake'):
                rpi_gpio.write(AIN1, direction == 'brake')
                rpi_gpio.write(AIN2, direction == 'brake')
        elif motor_side == 'B':
            if direction == 'forward':
                rpi_gpio.write(BIN1, True)
                rpi_gpio.write(BIN2, False)
            elif direction == 'backward':
                rpi_gpio.write(BIN1, False)
                rpi_gpio.write(BIN2, True)
            elif direction in ('coast', 'brake'):
                rpi_gpio.write(BIN1, direction == 'brake')
                rpi_gpio.write(BIN2, direction == 'brake')


# Public API (preserved from original)
def forward() -> None:
    """Drive all wheels forward."""
    _init_driver()
    LOGGER.info("Motors forward")
    _set_direction('A', 'forward')
    _set_direction('B', 'forward')
    _set_motor_speed(90, 90)


def backward() -> None:
    """Drive all wheels backward."""
    _init_driver()
    LOGGER.info("Motors backward")
    _set_direction('A', 'backward')
    _set_direction('B', 'backward')
    _set_motor_speed(90, 90)


def turn_left() -> None:
    """Pivot turn left: left backward, right forward."""
    _init_driver()
    LOGGER.info("Motors turn left")
    _set_direction('A', 'backward')
    _set_direction('B', 'forward')
    _set_motor_speed(70, 70)


def turn_right() -> None:
    """Pivot turn right: left forward, right backward."""
    _init_driver()
    LOGGER.info("Motors turn right")
    _set_direction('A', 'forward')
    _set_direction('B', 'backward')
    _set_motor_speed(70, 70)


def stop() -> None:
    """Stop motors (brake then coast)."""
    _init_driver()
    LOGGER.info("Motors stop")
    _set_motor_speed(0, 0)
    _set_direction('A', 'brake')
    _set_direction('B', 'brake')
    if not USE_SIM:
        time.sleep(0.1)
    _set_direction('A', 'coast')
    _set_direction('B', 'coast')


def cleanup() -> None:
    """Clean up GPIO and close handles."""
    global _h, _initialized
    if USE_SIM:
        LOGGER.info("Motor cleanup (sim)")
        return
    stop()
    if _h is not None:
        try:
            import lgpio as GPIO
            GPIO.gpio_write(_h, AIN1_PIN, GPIO.LOW)
            GPIO.gpio_write(_h, AIN2_PIN, GPIO.LOW)
            GPIO.gpio_write(_h, BIN1_PIN, GPIO.LOW)
            GPIO.gpio_write(_h, BIN2_PIN, GPIO.LOW)
            GPIO.gpio_write(_h, STBY_PIN, GPIO.LOW)
            GPIO.gpiochip_close(_h)
            LOGGER.info("Motor driver cleanup complete")
        except Exception as e:
            LOGGER.warning("Cleanup error: %s", e)
    _h = None
    _initialized = False
